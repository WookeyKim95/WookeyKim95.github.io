---
layout: post
title:  "[DirectX] DirectX 그리고 장치 초기화"
subtitle:  
date: 2022-11-28 20:00:23 +0900
categories: study
tags: WinAPI
comments: true
related_posts:

---

# [DirectX] DirectX 그리고 장치 초기화<br/>

## DirectX란?<br/>
<br/>

DirectX 라이브러리가 그래픽카드를 제어하는 함수를 모아놓은 것이다.<br/>

어떻게 프로그램이 장치를 제어하는 것일까?<br/>

DirectX 라이브러리는 Microsoft에서 제공하는 라이브러리로 그래픽카드가 연산을 하도록 명령을 모아놓은 라이브러리이다.<br/>

그리고 그래픽카드를 제어하는 언어는 비단 DirectX뿐만 아니라, OpenGL 이라는 언어도 존재한다.<br/>
<br/>

## DirectX를 VS에서 사용하기<br/>
<br/>

VS를 설치하면 DirectX 헤더가 따라온다. 그래서 미리 컴파일된 헤더(pch 등)나 global헤더에서 다음과 같은 내용을 입력해주면 된다.

```
// global 헤더

#include <d3d11.h>          // DirectX11
#include <d3dcompiler.h>    // Shader 컴파일
#include <DirectXMath.h>    // DX Math
#include <DirectXPackedVector.h> // 자주 사용하는 벡터 헤더

using namespace DirectX;
using namespace DirectX::PackedVector;

#pragma comment(lib, "d3d11")
#pragma comment(lib, "d3dcompiler")

```
<br/>

## 장치 초기화를 위한 CDevice 클래스 형성<br/>
<Br/>

```
// 헤더파일
class CDevice
    : public CSingleton<CDevice>
{
private:
    HWND    m_hWnd;

    ID3D11Device*        m_Device; // GPU 메모리 할당
    ID3D11DeviceContext* m_Context; // GPU 제어, 렌더링, 동작 수행

    IDXGISwapChain*      m_SwapChain;
    
    ID3D11Texture2D*     m_RTTex; 
    ID3D11RenderTargetView m_RTV;

    ID3D11Texture2D*     m_DSTex;
    ID3D11DepthStencilView* m_DSV;

    D3D11_VIEWPORT       m_ViewPort;

    // 렌더 타겟 해상도
    UINT                m_iRenderWidth; // GPU 렌더 상 해상도
    UINT                m_iRenderHeight; // GPU 렌더 상 해상도

public:
    int init(HWND _hWnd, UINT _iWidth, UINT _iHeight); // 초기화 함수

private:
    int CreateSwapChain();

public:
    CDevice();
    ~CDevice();
}
```

```
// cpp파일

#include "pch.h"
#include "CDevice.h"

CDevice::CDevice() :
    m_hWnd(nullptr),
    m_Device(nullptr),
    m_Context(nullptr),
    m_SwapChain(nullptr),
    m_RTTex(nullptr),
    m_RTV(nullptr),
    m_DSTex(nullptr),
    m_DSV(nullptr),
    m_ViewPort{}
{
}

CDevice::~CDevice()
{
    if(m_Device != nullptr) m_Device->Release();
    if(m_Context != nullptr) m_Context->Release();
    if(m_SwapChain != nullptr) m_SwapChain->Release();
    if(m_RTTex != nullptr) m_RTTex->Release();
    if(m_RTV != nullptr) m_RTV->Release();
    if(m_DSTex != nullptr) m_DSTex->Release();
    if(m_DSV != nullptr) m_DSV->Release();
}

int CDevice::init(HWND _hWnd, UINT _iWidth, UINT _iHeight)
{   
    m_hWnd = _hWnd;
    m_iRenderWidth = _iWidth;
    m_iRenderHeight = _iHeight;

    int iFlag = 0;

#ifdef _DEBUG
    iFlag = D3D11_CREATE_DEVICE_DEBUG; // Debug 버전에서 문제 발생 감지용
#endif

    D3D_FEATURE_LEVEL eLevel = D3D_FEATURE_LEVEL::D3D_FEATURE_LEVLE_11_0;

    if(FAILED(D3D11CreateDevice(nullptr,
                      D3D_DRIVER_TYPE_HARDWARE,
                      nullptr,
                      iFlag,
                      nullptr,
                      0,
                      D3D11_SDK_VERSION,
                      &m_Device,
                      &eLevel,
                      &m_Context)))
    {
        MessageBox(nullptr, L"Device, Context 생성 실패", L"Device 초기화 에러", MB_OK);
        return E_FAIL;
    };

    if (FAILED(CreateSwapChain()))
    {
        MessageBox(nullptr, L"SwapChain 생성 실패", L"Device 초기화 에러", MB_OK);
        return E_FAIL
    }

    return S_OK;
}

int CDevice::CreateSwapChain()
{
    DXGI_SWAP_CHAIN_DESC tDesc = {};

    tDesc.OutputWindow = m_hWnd; // 출력 윈도우
    tDesc.Windowed = true; // 창모드, 전체화면 모드 여부 (true : 창모드)

    tDesc.BufferCount = 1; // DirectX 11에서는 1을 넣고, 12 에서는 2를 넣는다.
    tDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
    tDesc.BufferDesc.Width = m_iRenderWidth; // 윈도우 해상도와 매치
    tDesc.BufferDesc.Height = m_iRenderHeight; // 윈도우 해상도와 매치
    tDesc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM; // RGBA 각 8비트
    tDesc.BufferDesc.RefreshRate.Denominator = 1; // 분자 (화면 갱신 비율)
    tDesc.BufferDesc.RefreshRate.Numerator = 60; // 분모 (화면 갱신 비율)
    tDesc.BufferDesc.Scaling = DXGI_MODE_SACLING_UNSPECIFIED;
    tDesc.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER::DXGI_MODE_SACNLINE_ORDER_UNSPECIFIED;

    tDesc.SampleDesc.Count = 1;
    tDesc.SampleDesc.Quality = 0;

    tDesc.Flags = 0;

    tDesc.SwapEffect = DXGI_SWAP_EFFECT::DXGI_SWAP_EFFECT_DISCARD;

    // SwapChain 생성
    IDXGIDevice* pDXGIDevice = nullptr;
    IDXGIAdapter* pAdapter = nullptr;
    IDXGIFactory* pFactory = nullptr;

    HRESULT hr = S_OK;

    hr = m_Device->QueryInterface(__uuidof(IDXGIDevice), (void**)&pDXGIDevice);
    hr = pDXGIDevice->GetParent(__uuidof(IDXGIAdapter), (void**)&pAdapter);
    hr = pAdapter->GetParent(__uuidof(IDXGIFactory), (void**)&pFactory);

    hr = pFactory->CreateSwapChain(m_Device, &tDesc, &m_SwapChain);

    pDXGIDevice->Release();
    pAdapter->Release();
    pFactoty->Release();

    return S_OK;
}
```

Device 클래스는 GPU에게 명령을 내리는 수단으로 사용될 것이다.<br/>

- ID3D11Device* : GPU 메모리 할당
- ID3D11DeviceContext* : GPU 제어, 렌더링, 동작 수행 



<br/>

### 시스템 메모리(RAM)의 4가지 영역과 저장되는 정보<br/>

- Stack 메모리 : 함수의 호출, 그리고 이와 관계된 지역변수와 전역변수
- Heap 메모리 : 동적으로 할당된 변수
- Code 메모리 : 코드
- Data 메모리 : 정적변수 전역변수

<br/>

### GPU의 특징<br/>

대량의 일을 처리하기 위해서 설계된 부품. CPU에 비해서 코어수가 압도적으로 많으나, GPU 코어의 연산 처리 능력은 CPU의 코어 보다 떨어진다.<br/>

그래서 대량의 단순 연산을 진행할 때 GPU가 적합하다.<br/>
<br/>

### FrontBuffer와 BackBuffer와 SwapChain<br/>
<br/>

GPU의 FrontBuffer의 그림을 시스템 메모리의 비트맵에 복사를 해서 윈도우에서 그림을 볼 수 있다.<br/>

즉, GPU의 그림을 시스템 메모리로 송출하는 역할을 한다.<br/>

BackBuffer에서 그림을 그렸으면 그 버퍼를 FrontBuffer로 바꾼다.<br/>
그렇게 FrontBuffer가 된 BackBuffer가 송출을 시작하고<br/>
BackBuffer가 된 FrontBuffer에서 그림을 그리기 시작한다.<br/>

이렇게 FrontBuffer와 BackBuffer가 매 프레임 마다 서로 바뀌는데<br/>
이들을 바꾸는 함수가 바로 SwapChain이다.<br/>